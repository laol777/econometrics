library("dplyr")
library("ggplot2")
library("GGally")
library("psych")
library(quantmod)
library(lmtest)
library(strucchange)


#Дан временной ряд потребления электрической энергии по ОЭС Урала за 2 месяца.
#Необходимо:
#1. Построить график временного ряда
#2. Проверить автокорреляцию уровней временного ряда, оценить наличие тенденции и периодических колебаний
#3. Определить наличие тенденции методами сравнения средних и Фостера-Стюарта
#4. Провести сглаживание временного ряда методом скользящей средней при g=2,3,5,6 и на основе результатов автокорреляции. Построить графики
#5. Обосновать выбор вида тенденции. Построить модель по выбранной тенденции
#6. Оценить адекватность полученной модели с помощью критерия серий, критерия Стьюдента,критерия Дарбина-Уотсона
#7. Посчитать дисперсию остатков, среднюю ошибку аппроксимации, коэффициент детерминации. Сделать вывод о полученных результатах
#8. Провести тест Чоу для временного ряда своего варианта и последующего



X = data.frame(
  index = c(1:61),
  value = c(590426,598539,592443,594720,575901,570319,596480,593475,592177,594807,595212,577716,576297,603203,
            605376,609844,614798,614393,599636,596120,623175,637830,633386,634110,630271,610160,606666,639621,
            631575,622167,621295,634864,621002,613055,645259,654188,648901,655976,658441,636323,630937,660735,
            669556,661558,657473,660151,635632,624844,654731,655316,663130,667519,674324,660260,657687,692815,
            697181,697266,686079,682641,665309)
           )



plot(X$value, type = "l")

# по оценке на глаз можно предположить, что есть и тенденция и периодические колебания

acf(X$value)


# видим затухающую корреляционную связь, но так же видим, что есть два всплеска - с лагом 7 и 14 - следовательно
# есть периодические колебания

## метод сравнения средних
X2 <- data.frame(x1 = X$value[1:30], x2 = X$value[31:60])
var.test(X2$x1, X2$x2)
# p == 0.458 -> не можем отвергнуть гипотезу об отстутстрии наличия тенденции

FosterStuart <- function(data)
{
  u = c()
  l = c()
  for(i in c(2:length(data)))
  {
    u[i] = 1
    l[i] = 1
    for(j in c(1:(i - 1)))
    {
      if(data[j] > data[i])
      {
        u[i] = 0
      }
      if(data[j] < data[i])
      {
        l[i] = 0
      }
    }
  }
  
  u <- u[2:length(u)]
  l <- l[2:length(l)]
  
  d <- u - l
  S <- u + l
  
  lf <- sqrt(2 * log(length(data)) - 3.4253)
  ff <- sqrt(2 * log(length(data)) - 0.8456)
  
  trendD <- d / ff
  trendMean <- (S - ff^2) / lf
  print(t.test(trendD)$p.value)
  print(t.test(trendMean)$p.value)
  
}

FosterStuart(X$value)
# 0.0001789607
# 4.694018e-71
# Проверяли схожесть выборок с распределением стьдента, что дало бы нам право уверждать об отсутвии тренда
# этого не произошло p-value ~ 0, что определяет наличие тренда

#сглаживание временного ряда
plot(X$value, type = "l")
smoothX <- data.frame(value = SMA(X$value, n=7)[7:61], index = c(7:61))
plot(SMA(X$value, n=2), type = "l")
plot(SMA(X$value, n=3), type = "l")
plot(SMA(X$value, n=5), type = "l")
plot(SMA(X$value, n=6), type = "l")
plot(SMA(X$value, n=7), type = "l")




# буду рассматривать видимую тенденцию, как имеющую монотонный характер развития и с отсутствующими пределами роста,
# так как полагать обратное не позволяют имещиеся данные или какие-либо априорные предположения
# буду аппроксимировать с помощью линейной функции

linearModel <- lm(value~index, data = smoothX)

predictedValue <- predict(linearModel, newdata = X)

# визуализация полученной модели
ggplot(data = X, aes(x = X$index, y = X$value)) + 
  geom_line(aes(x = X$index, y = X$value, color='Исходное' ), size=1) +
  geom_line(aes(x = X$index, y = SMA(X$value, n=7), color='Сглаженное' ), size=1) +
  geom_line(aes(x = X$index, y = predictedValue, color='Аппрок функция'), size=1.5) 


# тест стьюдента
t.test(predictedValue, X$value)
# p-value = 0.318


# дисперсия остатков
D <- var(X$value - predictedValue)
#178108128


#средняя ошибка аппроксимации
meanError <- sd(X$value - predictedValue) * sqrt(1 / length(X$value))
#1708.744

#коэффициент детерминации
ESS <- sum((X$value - predictedValue)^2)
RSS <- sum((predictedValue - mean(X$value))^2)
TSS <- ESS + RSS
R2 <- RSS / TSS
#0.821

# полученная модель достаточно точно описывает имеющиеся данные, это можно увидеть по графику,
# средняя ошибка аппроксимации равна 1708.744, по 1708.744 / (max(X$value) - min(X$value)), составляет 1.3%
# коэффициент детерминации равен 0.821, что достаточно близко к 1


sctest(X$value ~ X$index, type = "Chow", point = 3)



XNextVar = data.frame(
  index = c(1:61),
  value = c(662518,691382,692374,668756,703739,704328,690950,690747,724970,722096,715979,719874,
            719728,697580,686153,716357,714158,718562,712711,712649,692551,687253,716339,719423,
            713451,717397,717757,694335,682747,710200,708590,712710,709806,711320,696756,706487,
            749616,755118,753741,759247,764749,743912,734287,764344,779517,788502,796149,794054,
            775035,769339,799751,799042,787669,779511,771765,746092,742401,756150,746574,752355,
            735131)
)
plot(XNextVar$value, type = "l")
sctest(XNextVar$value ~ XNextVar$index, type = "Chow", point = 3)


linearModel$coefficients[1]


linearModel$coefficients[2]
